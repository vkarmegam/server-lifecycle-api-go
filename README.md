# Virtual Server Lifecycle Management API

## Overview

This project implements a backend service in Go that simulates the lifecycle of virtual servers, including provisioning, state transitions (start, stop, reboot, terminate), billing, logging, and observability. It provides a robust HTTP API to manage these virtual server instances without managing real infrastructure.

The service is built with a focus on idiomatic Go practices, clean architecture, dependency injection, and concurrency safety.

## Features

### Core HTTP API

* **`POST /server`**: Provision a new virtual server with specified name, region, and type.

* **`GET /servers/:id`**: Retrieve full metadata for a specific virtual server, including live uptime, billing information, and lifecycle logs.

* **`POST /servers/:id/action`**: Perform actions like `start`, `stop`, `reboot`, or `terminate` on a virtual server. Enforces valid state machine (FSM) transitions, returning `HTTP 409 Conflict` for invalid attempts.

* **`GET /servers`**: List all virtual servers, with support for filtering by region, status, and type. Includes pagination (`limit`, `offset`) and sorting (newest first).

* **`GET /servers/:id/logs`**: Return the last 100 lifecycle events for a specific server, implemented as a ring buffer.

### Bonus Features Implemented

* **Billing Daemon**: A background service that periodically calculates and updates the uptime-based cost for running servers (e.g., `$0.01/hr` for `t2.micro`).

* **Idle Reaper**: Automatically terminates servers that have been in a `stopped` state for more than 30 minutes.

* **Metrics Endpoint**: Exposes Prometheus-compatible metrics at `/metrics` for monitoring server counts, uptime, and other key application statistics.

  * **`server_total`**: A gauge representing the total number of virtual servers ever created.

  * **`server_current_status`**: A gauge vector (`GaugeVec`) tracking the count of servers by their current status (e.g., `provisioning`, `running`, `stopped`, `terminated`).

  * **`server_hourly_cost`**: A counter vector (`CounterVec`) tracking the accumulated hourly cost for each server.

  * **`server_uptime_seconds`**: A gauge vector (`GaugeVec`) representing the cumulative uptime in seconds for each server.

* **Health Endpoints**:

  * **`/healthz`**: A liveness probe to check if the application process is running.

  * **`/readyz`**: A readiness probe that checks connectivity to critical dependencies, such as the PostgreSQL database.

## Tech Stack

* **Language**: Go 1.22+

* **Web Framework**: [Chi](https://github.com/go-chi/chi) - A lightweight, idiomatic, and composable router for building Go HTTP services.

* **Database**: [PostgreSQL](https://www.postgresql.org/)

* **ORM/Query Builder**: [sqlc](https://sqlc.dev/) - Generates type-safe Go code from SQL queries.

* **Logging**: [Zap](https://github.com/uber-go/zap) - A fast, structured, leveled logging library.

* **Configuration**: [envconfig](https://github.com/kelseyhightower/envconfig) - Populates Go structs from environment variables.

* **API Documentation**: [Swaggo](https://github.com/swaggo/swag) - Automatically generates Swagger/OpenAPI 2.0 documentation from Go annotations.

## Architecture & Structure

The project follows a standard idiomatic Go project layout:

* **`cmd/server`**: Contains the `main` package and the entry point for the HTTP server application.

* **`internal/api`**: Defines HTTP handlers, routes, and API-specific request/response models.

* **`internal/services`**: Encapsulates the core business logic, state machine transitions.

* **`internal/database`**: Handles database connection management and provides the `sqlc.Queries` interface, and orchestration of database operations.

* **`internal/database/sqlc`**: Contains the Go code generated by `sqlc` from SQL queries.

* **`internal/models`**: Defines common data structures used across the application (e.g., `ServerResponse`, `BillingInfo`).

* **`internal/util`**: Houses general utility functions (e.g., logging setup, response helpers, type conversions).

* **`internal/middleware`**: Custom HTTP middleware (e.g., request ID propagation).

* **`docs/`**: Automatically generated Swagger documentation files.

## Setup and Running

### Prerequisites

* Go (1.22 or higher)

* PostgreSQL (14 or higher recommended)

* Docker and Docker Compose (for easy local setup)

* `swag` CLI tool (`go install github.com/swaggo/swag/cmd/swag@latest`)

### Local Development Setup

1. **Clone the repository:**

   ```bash
   git clone https://github.com/vkarmegam/server-lifecycle-api-go.git
   cd go-virtual-server
   ```
2. **Environment Configuration (.env file):**
Create a `.env` file in your project root (or your user's home directory if using godotenv.Load(filepath.Join(homeDir, ".env"))) with your database credentials and other settings.

``` bash
  # .env file configuration
  
  # HTTP Server Configuration
  HTTP_IP=127.0.0.1
  HTTP_PORT=8080
  
  # Database Configuration
  DB_HOST=127.0.0.1
  DB_PORT=5432
  DB_USER=postgres
  DB_PASSWORD=mysecretpassword
  DB_NAME=postgres
  DB_SSLMODE=disable
  
  # Application Specific Configuration
  IP_ALLOCATION_CIDR=192.168.0.0/24
  IP_EXCLUSION_LIST=192.168.0.1,192.168.0.255,192.168.0.100
  
  # Logging Configuration
  LOG_LEVEL=debug
  ENVIRONMENT=production
  LOG_FILE_CAPACITY_IN_MB=10
  
  # Database Retry Configuration
  DB_MAX_RETRIES=10
  DB_RETRY_DELAY=5s  
  
  # Billing Daemon Configuration
  BILLING_DAEMON_INTERVAL=1m
  
  # Server Type Pricing (comma-separated type:cost pairs)
  SERVER_TYPE_WISE_PRICING="micro:0.01,small:0.05,medium:0.10,large:0.20,xlarge:0.40"
```
3. **Database Setup:**
Ensure your PostgreSQL server is running. The application will attempt to connect to it.

4. Generate `sqlc` code: [if Needed] 

```Bash
sqlc generate
```
5. **Generate Swagger documentation:**

```Bash

swag init -g cmd/server/main.go --parseDependency --parseInternal
```
6. **Run the application locally:**

```Bash
go run ./cmd/server/main.go
```
* The API will be accessible at `http://localhost:8080`.

* Swagger UI will be available at `http://localhost:8080/swagger/index.html`.
  
* The Metrics `http://localhost:8080/metrics`

* PostgreSQL is expected to be running on port `5432` (or as configured).


 ###Running with Docker Compose
*** For a complete environment (backend + PostgreSQL + Swagger UI):

1. *Build Docker images:

```Bash
docker-compose build
```
2. *Start services:
```Bash
docker-compose up -d
```
* The API will be available at `http://localhost:8080`.

* Swagger UI will be available at `http://localhost:8081/`.

* PostgreSQL will be running on port 5432 (or as configured).


# API Endpoints #
You can explore the full API documentation via Swagger UI at `http://localhost:8080/swagger/index.html` when the server is running.

Here's a quick summary of the main endpoints:
```
Method	Path	                     Description
POST	/server	                     Provision a new virtual server.
GET	/servers	                     List all servers with filtering and pagination.
GET	/servers/{serverID}	           Retrieve full metadata for a specific server.
POST	/servers/{serverID}/action	 Perform actions (start, stop, reboot, terminate).
GET	/servers/{serverID}/logs	     Get the last 100 lifecycle events for a server.
GET	/metrics	                     Prometheus metrics endpoint.
GET	/healthz	                     Liveness probe.
GET	/readyz	                       Readiness probe (checks DB connectivity).

```
# Contributing #
Feel free to open issues or submit pull requests.

# License #
This project is licensed under the MIT License.

# Author #
Karmegam Vadivel

* GitHub: https://github.com/vkarmegam

* LinkedIn: https://www.linkedin.com/in/karmegamv
